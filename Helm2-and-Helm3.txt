helm====== helm is a package manager that creates and manages the charts and all the deployements 

helm2 there are two componants
1)tiller-server
2)client
client interacts with triller and also manages the charts
triller interacts and comminicate with kubernetes-api server and deployes kubernetes objects on cluster

=====================================

helm3====is basically client only architecture it directly interacts with kubernetes-api server
triller is removed in helm3


=====================================

why we need helm charts??

we can have all the obejcts of kubernetes as a template we dont need to run specific deployements for specific objects
just we can run helm command for all objects whic are present in template

helm make deployment easy

=====>>we can reuse tmplates becouse we write metadata and function that can reuse for other templates


package-name/
    charts/=======>> directory is used for manage the chart dependencies 
	teplates/  =====>> this contains the files like deployements,service and other
	     _helpers==== for functions
	chart.yml=====>> this is actually contains metadata about chart such as name and version, maintainer information
	licence
	readme.md
	requirements.yml=====>> this has chart dependencies
	values.yml===========>> this will have default configuration values those are used in objects for deployements
	
==============================================

workflow---- teplates have manifest files in that we interpolate values which are accessed by values.yml and functions from _helpers


================================================
Diffrence between helm2 and helm3??

---->> triller has been removed
----->> when helm2 there was no rbac for autherisation and authentication for that triller is removed
----->> in helm2 that maintaining the state of release and dployments in triller but in helm3 it directly maintaining helm3 client itself
----->> in helm3 the upgrade strategy 3-way strategic merge patches whereas helm2 2-way merge strategy
----->> in helm2 if the pod has two containers and two containers have to diffrents versions if we change any one container version it will deploy only on but in helm3 the present state as well as previous changes also updated
----->> helm2 we cant use the same name in multiple time but helm3 we can have same name in multiple namespaces
----->> release information about chart stored in configmap but in hlem3 these information stored in secrets
----->> in helm2 if we did not provide any name then autogenerated names provided but hlem3 it thows a error we should provide a name

helm create chartname----creates charts

what test folder in template folder---- we can keep a test application manifest and we can test that
 
metadata---->> we will have labels
	
.helmignore---that can ignore any any file which we dont want


helm lint mychart---it validate syntax of chart

helm install --dry-run --debug ./mychart

helm install example ./mychart --set service.type=Nodeport

helm list

helm uninstall example

source <(helm compleateion bash)

helm create test(chart)

=======================>>> dependencies in chart.yml
   dependencies:
   - name: appmesh-controller
     version: "0.5.0"
	 repository: "https://aws.github.io/eks-charts"
	 
------>> helm dep test
------>> helm dep update test


=================================

helm get all test

helm get hooks test

=========>> hooks are the mechanism that trigger for any event that should install or upgrade
for exaple if we redeploying database that we alway take a backup then redeployed we can use hooks that it will take a backup and redploy

helm get manifesttest ----for getting all manifests in chart

helm get notes test

helm get values test -a 

helm history test---release history and revision

helm history test -o json

helm ugrade test mychart

helm install test ./testchart --set service.type=Nodeport --no-hooks

helm install ./testchart --generate-name

helm repo add repname(jfrog) https://charts.jfrog.io 

helm install jfrog/artifactory-oss --version 2.2.2 --repo  https://charts.jfrog.io 

helm list --all-namespaces

helm ls --all-namespaces --max 1 --failed

helm install test mychart --namespace default

===========>>> if we want to package and take artifact of chrats we need to use helm package and stores it to jfrog or s3

helm package test

helm package test --destination --version 1.2.3

helm plugin install url(pluggin url)

helm diff ugrade test mychart(folder of chart) --values mychart/values.yml

helm pluggin update plugin-name

helm plugin unnistall plugin-name

helm plugin list

helm pull chartname --version 6.2.0 --repo url

helm repo list

helm repo update

helm repo removed

helm rollback test 1

helm rollback test 1 --force --no-hooks

helm search hub nginx 

helm search repo nginx --devel

helm show chart test 

helm status test -o json

helm test tesfolder


================================>>> build it objects in helm

A object is a combination of data and procedures working on the available data.
An object has statea and behaviour.The state os an object is stored in fields (variables), while methods (functions) display the objects behaviour.

---->> objects are passed into a template from the template engine
---->> code can pass objects around and there are even few ways to create new objects
within your templates like with and tuple function
 
1)Release--->> this object describes the release itself.it has severel objects

Release.Name
Release.Namespace
Release.IsUpgrade
Release.IsInstall
Release.Revision
Release.Service

2)charts--->> this has contents of the chart.yml and chart data will accessible

{{-define "mychart.chart"}}
{{-printf .chart.name chart.Version}}

3) files---->> this provides access to non-special files in a chart

Files.Get
Files.GetBytes
Files.Glob
Files.Lines
Files.AsSecrets
Files.AsConfig

4)Values--->> values passed into the template from the values.yml file from user-supplied files. by default, values is empty

image: "{{ .Values.image.repository }}

5)capabilities--->> this provides information about what capabilities the kubernetes cluster supports

Capabilities.APIVersions
Capabilities.APIVersions.Has $version
Capabilities.KubeVersion
Capabilities.KubeVersion.Major
Capabilities.KubeVersion.Minor

6)template---->> containes information about current template that is being executed

Name
Basepath


===========================================>>>>>funcitions, pipeliens and objects

60 available functions in helm

helm supports pipelines that checnges series of commands to another command to get a required output or result--- is like piping in linux

functions----->>
1.quote
2.repeate
3.upper
4.lower
5.include
6.required
7.defult
8.nindent
9.indent
10.toYaml

pipeliens---->>

image: "{{ .Values.image.repository | nindent 6}}


======================================>>>> control structure provides the templates with the ability to control the flow of template generation

if/else--->> for creating conditions
with--->> to specify a scope
range--->> which provides a "for each" -style loop


if and else=============>>>

{{ if pipline }}
  #do somthing
{{ else if other-pipline }}
  # do somthing
{{ else }}
  #default case
{{ end }}

sample function.yml=========>>>

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | defult "tea" | quote }}
  food: {{ .food | upper | qoute }}
  food1: {{ id eq .Values.favorite.drink "coffee" }}
  mug: true
  {{ end }}
  {{- end}}
  topping: |-
    {{- range .pizzaToppings }}
	- {{ . | title | qoute }}
	{{- end }}
	


to clear spaces use ====== "-" and "**"

=================================>>>>with ---->> this controls variables scoping


{{ with pipline }}
 # restricted scope
{{ end }}

==========>>>>variables

{{- $releaseName := .Release.Name -}}

Named-templates====used for declare a condition to reuse

{{ -define "mychart.labels" }}
  labels:
    generator: helm
	date: {{ now | htmlDate }}
{{- end }}









